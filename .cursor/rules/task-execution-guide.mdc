---
description: Guide for executing tasks, managing dependencies, and tracking progress
globs: **/*
alwaysApply: true
---
# Task Execution Guide

## Overview

This guide provides step-by-step strategies for implementing features from completed specs, maintaining quality throughout the development process, and handling common implementation challenges.

## Pre-Implementation Setup

### 1. Spec Validation
Before starting implementation, ensure your spec is complete:

- **Requirements Review**: All user stories have clear acceptance criteria
- **Design Completeness**: Architecture and components are well-defined
- **Task Clarity**: Each task is actionable and has clear deliverables
- **Dependency Mapping**: Task order and dependencies are understood

### 2. Environment Preparation
Set up your development environment:

```bash
# Ensure development dependencies are installed
# Set up testing framework
# Configure code quality tools (linting, formatting)
# Prepare version control branching strategy
```

### 3. Task Prioritization
Review the task list and identify:
- **Critical Path**: Tasks that block other work
- **Quick Wins**: Simple tasks that provide early validation
- **Risk Areas**: Complex tasks that may need extra attention
- **Integration Points**: Tasks that connect different components

## Task Execution Strategy

### Single Task Focus Approach

**Rule**: Implement one task at a time, completely, before moving to the next.

#### Step 1: Task Analysis
Before coding, analyze the current task:

1. **Read Task Details**: Understand what needs to be built
2. **Review Requirements**: Check which requirements this task addresses
3. **Check Dependencies**: Ensure prerequisite tasks are complete
4. **Plan Implementation**: Outline your approach before coding

#### Step 2: Implementation Process

```markdown
For each task:
1. Update task status to "in progress"
2. Create/modify necessary files
3. Write tests (if applicable)
4. Implement functionality
5. Validate against requirements
6. Update task status to "complete"
7. Commit changes with clear message
```

#### Step 3: Validation Checkpoint
After completing each task:
- **Functionality Test**: Does it work as specified?
- **Requirements Check**: Are the referenced requirements satisfied?
- **Integration Test**: Does it work with existing code?
- **Code Quality**: Is it maintainable and well-documented?

### Implementation Patterns

#### Test-Driven Development Integration
When tasks involve testable functionality:

1. **Write Tests First**: Based on acceptance criteria
2. **Implement to Pass**: Write minimal code to satisfy tests
3. **Refactor**: Improve code quality while maintaining tests
4. **Validate**: Ensure all requirements are met

#### Incremental Building
For complex tasks:

1. **Start Simple**: Implement basic functionality first
2. **Add Complexity**: Layer on additional features
3. **Validate Frequently**: Test after each increment
4. **Document Decisions**: Record any deviations from the plan

## Quality Maintenance Strategies

### Code Quality Standards
- **Consistent Formatting**: Use project-specific style guides
- **Clear Naming**: Use descriptive variable and function names
- **Documentation**: Include comments for complex logic
- **Error Handling**: Implement comprehensive error handling

### Testing Strategy
- **Unit Tests**: Test individual functions and components
- **Integration Tests**: Test component interactions
- **End-to-End Tests**: Test complete user workflows
- **Performance Tests**: Validate performance requirements

### Code Review Process
- **Self Review**: Review your own code before committing
- **Peer Review**: Get feedback from team members
- **Automated Checks**: Use linting and formatting tools
- **Documentation Review**: Ensure documentation is updated

## Common Implementation Challenges

### Challenge 1: Unclear Requirements
**Problem**: Task requirements are vague or ambiguous
**Solution**: 
- Clarify requirements with stakeholders
- Break down unclear tasks into smaller, clearer tasks
- Document assumptions and decisions
- Create prototypes to validate understanding

### Challenge 2: Technical Complexity
**Problem**: Task is more complex than initially estimated
**Solution**:
- Break complex tasks into smaller subtasks
- Research technical approaches before implementation
- Create proof-of-concept implementations
- Seek expert advice when needed

### Challenge 3: Integration Issues
**Problem**: New code doesn't integrate well with existing system
**Solution**:
- Understand existing system architecture
- Follow established patterns and conventions
- Test integration points thoroughly
- Plan for backward compatibility

### Challenge 4: Performance Issues
**Problem**: Implementation doesn't meet performance requirements
**Solution**:
- Profile code to identify bottlenecks
- Optimize critical paths
- Consider caching strategies
- Test with realistic data volumes

## Implementation Best Practices

### 1. Start with the Foundation
- Implement core data models first
- Set up basic infrastructure
- Create essential interfaces
- Establish testing framework

### 2. Build Incrementally
- Implement features in small, testable increments
- Validate each increment before moving to the next
- Maintain working code at all times
- Use feature flags for complex integrations

### 3. Test Continuously
- Write tests alongside implementation
- Run tests frequently during development
- Use automated testing where possible
- Validate against acceptance criteria

### 4. Document as You Go
- Update documentation with code changes
- Document design decisions and rationale
- Keep README files current
- Maintain API documentation

### 5. Handle Errors Gracefully
- Implement comprehensive error handling
- Provide meaningful error messages
- Log errors for debugging
- Plan for error recovery

## Task-Specific Implementation Patterns

### Database Tasks
```typescript
// Example: Database schema implementation
1. Create migration files
2. Define data models
3. Implement repository layer
4. Add validation logic
5. Write integration tests
6. Update documentation
```

### API Tasks
```typescript
// Example: API endpoint implementation
1. Define route structure
2. Implement request validation
3. Add business logic
4. Handle error cases
5. Write unit tests
6. Add integration tests
```

### UI Component Tasks
```typescript
// Example: React component implementation
1. Create component structure
2. Implement core functionality
3. Add styling and theming
4. Handle user interactions
5. Add accessibility features
6. Write component tests
```

### Integration Tasks
```typescript
// Example: Third-party service integration
1. Research API documentation
2. Create service wrapper
3. Implement error handling
4. Add retry logic
5. Write integration tests
6. Monitor performance
```

## Progress Tracking and Reporting

### Task Status Tracking
- **Not Started**: Task hasn't been begun
- **In Progress**: Task is currently being worked on
- **Blocked**: Task is waiting for dependencies
- **Review**: Task is ready for review
- **Complete**: Task is finished and validated

### Progress Reporting
```markdown
## Implementation Progress Report

### Completed Tasks
- [x] Task 1: Set up project structure
- [x] Task 2: Implement core data models
- [x] Task 3: Create basic API endpoints

### In Progress
- [ ] Task 4: Implement authentication system
- [ ] Task 5: Add user interface components

### Blocked
- [ ] Task 6: Integration with external service (waiting for API access)

### Upcoming
- [ ] Task 7: Add comprehensive testing
- [ ] Task 8: Performance optimization
```

## Risk Management

### Technical Risks
- **Identify**: List potential technical challenges
- **Assess**: Evaluate likelihood and impact
- **Mitigate**: Plan strategies to reduce risk
- **Monitor**: Track risk status throughout implementation

### Timeline Risks
- **Buffer Time**: Add extra time for complex tasks
- **Parallel Work**: Identify tasks that can be done simultaneously
- **Early Validation**: Test critical assumptions early
- **Contingency Plans**: Have backup approaches ready

### Quality Risks
- **Code Reviews**: Ensure all code is reviewed
- **Testing Coverage**: Maintain high test coverage
- **Documentation**: Keep documentation current
- **Performance Monitoring**: Track performance metrics

## Integration with Kiro Methodology

### Requirements Phase Integration
- Reference specific requirements in implementation
- Validate implementation against acceptance criteria
- Update requirements if implementation reveals issues
- Maintain traceability between requirements and code

### Design Phase Integration
- Follow architectural decisions from design phase
- Implement components according to design specifications
- Update design if implementation reveals better approaches
- Document any deviations from original design

### Tasks Phase Integration
- Execute tasks in the planned order
- Update task status as work progresses
- Identify new tasks if implementation reveals gaps
- Validate task completion against original objectives

## Continuous Improvement

### Learning from Implementation
- Document lessons learned during implementation
- Identify patterns that work well
- Note areas for improvement
- Share knowledge with team members

### Process Refinement
- Update task estimation based on actual effort
- Improve task breakdown for future projects
- Refine implementation patterns
- Enhance quality assurance processes

### Tool and Technology Evaluation
- Assess effectiveness of development tools
- Evaluate new technologies and approaches
- Update technology stack recommendations
- Improve development environment setup

## Troubleshooting Implementation Issues

### When Tasks Take Longer Than Expected
- Break down large tasks into smaller ones
- Identify and address blocking issues
- Reassess task complexity and dependencies
- Consider alternative implementation approaches

### When Requirements Change During Implementation
- Assess impact of changes on current work
- Update task plan to accommodate changes
- Communicate changes to stakeholders
- Revalidate implementation against new requirements

### When Quality Issues Arise
- Increase testing coverage
- Add more code reviews
- Implement additional quality checks
- Consider refactoring problematic code

### When Performance Issues Occur
- Profile code to identify bottlenecks
- Optimize critical performance paths
- Consider architectural changes if needed
- Implement performance monitoring

Follow this task execution guide to systematically implement features from specs while maintaining high quality and managing risks effectively.
description:
globs:
alwaysApply: false
---
