---
description: Comprehensive testing standards including unit, integration, and end-to-end testing
globs: **/*
alwaysApply: true
---
# Testing Practices

## Testing Philosophy

### Testing Pyramid
```
    /\
   /  \     E2E Tests (Few)
  /____\    Integration Tests (Some)
 /      \   
/________\   Unit Tests (Many)
```

### Core Principles
- **Test Behavior, Not Implementation**: Focus on what code does, not how
- **Fast Feedback**: Tests run quickly for immediate feedback
- **Reliable**: Deterministic tests that don't flake
- **Maintainable**: Easy to understand and update
- **Comprehensive**: Cover happy paths, edge cases, and errors

## Unit Testing

### React Component Testing
```typescript
// ✅ Good: Test user interactions and behavior
import { render, screen, fireEvent } from '@testing-library/react';

describe('LoginForm', () => {
  it('submits form with user input', async () => {
    const mockSubmit = jest.fn();
    render(<LoginForm onSubmit={mockSubmit} />);
    
    fireEvent.change(screen.getByLabelText(/email/i), {
      target: { value: 'test@example.com' },
    });
    fireEvent.change(screen.getByLabelText(/password/i), {
      target: { value: 'password123' },
    });
    fireEvent.click(screen.getByRole('button', { name: /login/i }));
    
    expect(mockSubmit).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password123',
    });
  });

  it('displays validation errors for invalid input', () => {
    render(<LoginForm onSubmit={jest.fn()} />);
    fireEvent.click(screen.getByRole('button', { name: /login/i }));
    
    expect(screen.getByText(/email is required/i)).toBeInTheDocument();
    expect(screen.getByText(/password is required/i)).toBeInTheDocument();
  });
});
```

### Custom Hook Testing
```typescript
// ✅ Good: Test hook behavior and state changes
import { renderHook, act } from '@testing-library/react';

describe('useCounter', () => {
  it('increments counter correctly', () => {
    const { result } = renderHook(() => useCounter(0));
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(1);
  });

  it('resets counter to initial value', () => {
    const { result } = renderHook(() => useCounter(5));
    
    act(() => {
      result.current.increment();
      result.current.reset();
    });
    
    expect(result.current.count).toBe(5);
  });
});
```

### Utility Function Testing
```typescript
// ✅ Good: Test pure functions thoroughly
describe('formatDate', () => {
  it('formats date correctly', () => {
    const date = new Date('2024-01-15');
    expect(formatDate(date)).toBe('January 15, 2024');
  });

  it('handles invalid dates', () => {
    expect(formatDate(null)).toBe('Invalid date');
    expect(formatDate(undefined)).toBe('Invalid date');
  });
});

describe('calculateTotal', () => {
  it('calculates total with tax', () => {
    const items = [
      { price: 10, quantity: 2 },
      { price: 5, quantity: 1 },
    ];
    expect(calculateTotal(items, 0.1)).toBe(27.5);
  });

  it('handles empty items', () => {
    expect(calculateTotal([], 0.1)).toBe(0);
  });
});
```

## Integration Testing

### API Route Testing
```typescript
// ✅ Good: Test complete API workflows
import request from 'supertest';
import { app } from '../app';

describe('POST /api/users', () => {
  beforeEach(async () => {
    await prisma.user.deleteMany();
  });

  it('creates user with valid data', async () => {
    const userData = {
      email: 'test@example.com',
      password: 'password123',
      name: 'Test User',
    };

    const response = await request(app)
      .post('/api/users')
      .send(userData)
      .expect(201);

    expect(response.body).toMatchObject({
      id: expect.any(String),
      email: userData.email,
      name: userData.name,
    });
    expect(response.body).not.toHaveProperty('password');
  });

  it('returns validation error for invalid data', async () => {
    const response = await request(app)
      .post('/api/users')
      .send({ email: 'invalid' })
      .expect(400);

    expect(response.body).toHaveProperty('errors');
  });
});
```

### Database Integration Testing
```typescript
// ✅ Good: Test database operations
describe('User Service', () => {
  beforeEach(async () => {
    await prisma.user.deleteMany();
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  it('creates user successfully', async () => {
    const userData = {
      email: 'test@example.com',
      password: 'hashedPassword',
      name: 'Test User',
    };

    const user = await createUser(userData);

    expect(user).toMatchObject({
      id: expect.any(String),
      email: userData.email,
      name: userData.name,
    });
  });

  it('throws error for duplicate email', async () => {
    const userData = {
      email: 'test@example.com',
      password: 'password',
      name: 'Test User',
    };

    await createUser(userData);
    await expect(createUser(userData)).rejects.toThrow('Email already exists');
  });
});
```

## End-to-End Testing

### User Journey Testing
```typescript
// ✅ Good: Test complete user workflows
import { test, expect } from '@playwright/test';

test.describe('User Authentication Flow', () => {
  test('user can register and login', async ({ page }) => {
    // Registration
    await page.goto('/register');
    await page.fill('[data-testid="email-input"]', 'test@example.com');
    await page.fill('[data-testid="password-input"]', 'password123');
    await page.fill('[data-testid="name-input"]', 'Test User');
    await page.click('[data-testid="register-button"]');
    
    // Verify redirect and success
    await expect(page).toHaveURL('/login');
    await expect(page.locator('[data-testid="success-message"]'))
      .toContainText('Registration successful');
    
    // Login with new account
    await page.fill('[data-testid="email-input"]', 'test@example.com');
    await page.fill('[data-testid="password-input"]', 'password123');
    await page.click('[data-testid="login-button"]');
    
    // Verify successful login
    await expect(page).toHaveURL('/dashboard');
    await expect(page.locator('[data-testid="user-name"]'))
      .toContainText('Test User');
  });
});
```

### Critical Path Testing
```typescript
// ✅ Good: Test business-critical workflows
test.describe('E-commerce Checkout', () => {
  test('complete purchase flow', async ({ page }) => {
    // Browse and add to cart
    await page.goto('/products');
    await page.click('[data-testid="product-card"]');
    await page.click('[data-testid="add-to-cart"]');
    
    // Proceed to checkout
    await page.click('[data-testid="checkout-button"]');
    
    // Fill shipping information
    await page.fill('[data-testid="name-input"]', 'John Doe');
    await page.fill('[data-testid="address-input"]', '123 Main St');
    
    // Fill payment information
    await page.fill('[data-testid="card-number"]', '4242424242424242');
    await page.fill('[data-testid="expiry"]', '12/25');
    
    // Complete purchase
    await page.click('[data-testid="place-order"]');
    
    // Verify order confirmation
    await expect(page).toHaveURL(/\/order\/\d+/);
    await expect(page.locator('[data-testid="order-status"]'))
      .toContainText('Confirmed');
  });
});
```

## Test Organization

### File Structure
```
src/
├── components/
│   ├── Button/
│   │   ├── Button.tsx
│   │   ├── Button.test.tsx
│   │   └── index.ts
├── utils/
│   ├── formatDate.ts
│   ├── formatDate.test.ts
└── services/
    ├── userService.ts
    └── userService.test.ts
```

### Test Configuration
```typescript
// jest.config.js
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/src/test/setup.ts'],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/test/**/*',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
};
```

## Mocking and Test Data

### API Mocking with MSW
```typescript
// ✅ Good: Mock API responses consistently
import { rest } from 'msw';
import { setupServer } from 'msw/node';

const server = setupServer(
  rest.get('/api/users', (req, res, ctx) => {
    return res(
      ctx.json([
        { id: '1', name: 'John Doe', email: 'john@example.com' },
        { id: '2', name: 'Jane Smith', email: 'jane@example.com' },
      ])
    );
  }),

  rest.post('/api/users', (req, res, ctx) => {
    const { name, email } = req.body as any;
    return res(
      ctx.status(201),
      ctx.json({ id: '3', name, email })
    );
  })
);

export { server };
```

### Test Data Factories
```typescript
// ✅ Good: Generate consistent test data
import { faker } from '@faker-js/faker';

export const createUser = (overrides = {}) => ({
  id: faker.string.uuid(),
  email: faker.internet.email(),
  name: faker.person.fullName(),
  createdAt: faker.date.past(),
  ...overrides,
});

export const createPost = (overrides = {}) => ({
  id: faker.string.uuid(),
  title: faker.lorem.sentence(),
  content: faker.lorem.paragraphs(),
  authorId: faker.string.uuid(),
  createdAt: faker.date.past(),
  ...overrides,
});
```

## Performance Testing

### Load Testing
```typescript
// ✅ Good: Test application under load
test.describe('Performance Tests', () => {
  test('page loads within acceptable time', async ({ page }) => {
    const startTime = Date.now();
    await page.goto('/dashboard');
    const loadTime = Date.now() - startTime;
    
    expect(loadTime).toBeLessThan(3000); // 3 seconds
  });

  test('API responds quickly', async ({ request }) => {
    const startTime = Date.now();
    const response = await request.get('/api/users');
    const responseTime = Date.now() - startTime;
    
    expect(responseTime).toBeLessThan(1000); // 1 second
    expect(response.status()).toBe(200);
  });
});
```

### Memory and Resource Testing
```typescript
// ✅ Good: Monitor resource usage
test('does not leak memory', async ({ page }) => {
  const initialMemory = await page.evaluate(() => performance.memory?.usedJSHeapSize);
  
  // Perform operations that might leak memory
  for (let i = 0; i < 100; i++) {
    await page.click('[data-testid="create-item"]');
    await page.click('[data-testid="delete-item"]');
  }
  
  const finalMemory = await page.evaluate(() => performance.memory?.usedJSHeapSize);
  const memoryIncrease = finalMemory - initialMemory;
  
  expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024); // 10MB threshold
});
```

## Test Quality Standards

### Coverage Requirements
```typescript
// Coverage thresholds by component type
const coverageThreshold = {
  global: {
    branches: 80,
    functions: 80,
    lines: 80,
    statements: 80,
  },
  './src/components/': {
    branches: 90,
    functions: 90,
    lines: 90,
    statements: 90,
  },
  './src/utils/': {
    branches: 95,
    functions: 95,
    lines: 95,
    statements: 95,
  },
};
```

### Test Naming Conventions
```typescript
// ✅ Good: Descriptive test names
describe('UserService', () => {
  describe('createUser', () => {
    it('should create user with valid data', () => {});
    it('should throw error when email already exists', () => {});
    it('should hash password before saving', () => {});
  });

  describe('getUserById', () => {
    it('should return user when found', () => {});
    it('should return null when user not found', () => {});
  });
});
```

### Test Isolation
```typescript
// ✅ Good: Isolated, independent tests
describe('UserService', () => {
  beforeEach(async () => {
    await prisma.user.deleteMany(); // Clean state
  });

  afterEach(async () => {
    jest.clearAllMocks(); // Reset mocks
  });

  it('creates user independently', async () => {
    // Test implementation that doesn't depend on other tests
  });
});
```

## Best Practices

### Do's
- Write tests that focus on behavior, not implementation
- Use descriptive test names that explain the scenario
- Keep tests isolated and independent
- Mock external dependencies appropriately
- Test both happy paths and error cases
- Use test data factories for consistent data
- Set appropriate coverage thresholds
- Run tests in CI/CD pipeline

### Don'ts
- Test implementation details
- Write flaky tests that depend on timing
- Skip testing error scenarios
- Use hardcoded test data
- Ignore test coverage metrics
- Test third-party library functionality
- Write slow tests without good reason
- Skip integration tests for critical paths

### Testing Checklist
- [ ] Unit tests for all business logic
- [ ] Integration tests for API endpoints
- [ ] E2E tests for critical user journeys
- [ ] Performance tests for key workflows
- [ ] Error handling tests for failure scenarios
- [ ] Mock external dependencies appropriately
- [ ] Maintain high test coverage (80%+)
- [ ] Use descriptive test names
- [ ] Keep tests fast and reliable

This comprehensive testing approach ensures code quality, reliability, and maintainability across all application components.