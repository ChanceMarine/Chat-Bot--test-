---
description: Security standards, authentication, authorization, and data protection guidelines
globs: **/*
alwaysApply: true
---
# Security Standards

## Overview

This rule defines security standards and best practices for web applications, including authentication, authorization, data protection, input validation, and security monitoring.

## Authentication Standards

### JWT Token Implementation
```typescript
// ✅ Good: Secure JWT implementation
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET!;
const JWT_EXPIRES_IN = '1h';

export const generateToken = (payload: TokenPayload): string => {
  return jwt.sign(payload, JWT_SECRET, {
    expiresIn: JWT_EXPIRES_IN,
    issuer: 'your-app',
    audience: 'your-app-users',
  });
};

export const verifyToken = (token: string): TokenPayload => {
  try {
    return jwt.verify(token, JWT_SECRET, {
      issuer: 'your-app',
      audience: 'your-app-users',
    }) as TokenPayload;
  } catch (error) {
    throw new Error('Invalid token');
  }
};

// ✅ Good: Token payload interface
interface TokenPayload {
  userId: string;
  email: string;
  role: 'user' | 'admin';
  iat?: number;
  exp?: number;
  iss?: string;
  aud?: string;
}
```

### Password Security
```typescript
// ✅ Good: Secure password hashing
import bcrypt from 'bcrypt';

const SALT_ROUNDS = 12;

export const hashPassword = async (password: string): Promise<string> => {
  return bcrypt.hash(password, SALT_ROUNDS);
};

export const verifyPassword = async (
  password: string,
  hashedPassword: string
): Promise<boolean> => {
  return bcrypt.compare(password, hashedPassword);
};

// ✅ Good: Password validation
const passwordSchema = z.object({
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
    .regex(/[0-9]/, 'Password must contain at least one number')
    .regex(/[^A-Za-z0-9]/, 'Password must contain at least one special character'),
});
```

### Session Management
```typescript
// ✅ Good: Secure session handling
export const createSession = async (userId: string): Promise<Session> => {
  const sessionId = crypto.randomUUID();
  const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

  const session = await prisma.session.create({
    data: {
      id: sessionId,
      userId,
      expiresAt,
      userAgent: req.headers['user-agent'] || '',
      ipAddress: req.ip || '',
    },
  });

  return session;
};

export const validateSession = async (sessionId: string): Promise<Session | null> => {
  const session = await prisma.session.findUnique({
    where: { id: sessionId },
    include: { user: true },
  });

  if (!session || session.expiresAt < new Date()) {
    return null;
  }

  return session;
};
```

## Authorization Standards

### Role-Based Access Control (RBAC)
```typescript
// ✅ Good: RBAC implementation
enum UserRole {
  USER = 'user',
  MODERATOR = 'moderator',
  ADMIN = 'admin',
}

interface Permission {
  resource: string;
  action: string;
  conditions?: Record<string, any>;
}

const rolePermissions: Record<UserRole, Permission[]> = {
  [UserRole.USER]: [
    { resource: 'profile', action: 'read' },
    { resource: 'profile', action: 'update' },
  ],
  [UserRole.MODERATOR]: [
    { resource: 'profile', action: 'read' },
    { resource: 'profile', action: 'update' },
    { resource: 'content', action: 'moderate' },
  ],
  [UserRole.ADMIN]: [
    { resource: '*', action: '*' },
  ],
};

export const hasPermission = (
  userRole: UserRole,
  resource: string,
  action: string
): boolean => {
  const permissions = rolePermissions[userRole];
  return permissions.some(
    (permission) =>
      (permission.resource === resource || permission.resource === '*') &&
      (permission.action === action || permission.action === '*')
  );
};
```

### Route Protection
```typescript
// ✅ Good: Protected route middleware
export const requireAuth = (req: Request, res: Response, next: NextFunction) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  
  if (!token) {
    return res.status(401).json({ error: 'Authentication required' });
  }

  try {
    const payload = verifyToken(token);
    req.user = payload;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
};

export const requireRole = (roles: UserRole[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }

    next();
  };
};

// ✅ Good: Usage in routes
app.get('/admin/users', requireAuth, requireRole([UserRole.ADMIN]), (req, res) => {
  // Admin only route
});
```

## Input Validation and Sanitization

### Request Validation
```typescript
// ✅ Good: Comprehensive input validation
import { z } from 'zod';

const createUserSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: passwordSchema.shape.password,
  name: z.string().min(2).max(100),
  age: z.number().min(13).max(120),
});

export const validateCreateUser = (data: unknown) => {
  return createUserSchema.parse(data);
};

// ✅ Good: API route with validation
app.post('/users', async (req, res) => {
  try {
    const validatedData = validateCreateUser(req.body);
    const user = await createUser(validatedData);
    res.status(201).json(user);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ 
        error: 'Validation failed', 
        details: error.errors 
      });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});
```

### SQL Injection Prevention
```typescript
// ✅ Good: Use parameterized queries
export const getUserById = async (id: string): Promise<User | null> => {
  return prisma.user.findUnique({
    where: { id },
    select: { id: true, email: true, name: true },
  });
};

// ❌ Avoid: Raw SQL with string concatenation
// const query = `SELECT * FROM users WHERE id = '${id}'`;
```

### XSS Prevention
```typescript
// ✅ Good: Sanitize user input
import DOMPurify from 'dompurify';

export const sanitizeHtml = (input: string): string => {
  return DOMPurify.sanitize(input);
};

// ✅ Good: Use React's built-in XSS protection
const UserComment: React.FC<{ comment: string }> = ({ comment }) => {
  // React automatically escapes content
  return <div>{comment}</div>;
};

// ✅ Good: For trusted HTML, use dangerouslySetInnerHTML carefully
const TrustedContent: React.FC<{ html: string }> = ({ html }) => {
  const sanitizedHtml = sanitizeHtml(html);
  return <div dangerouslySetInnerHTML={{ __html: sanitizedHtml }} />;
};
```

## Data Protection

### Environment Variables
```bash
# ✅ Good: Use environment variables for secrets
JWT_SECRET=your-super-secret-jwt-key
DATABASE_URL=postgresql://user:pass@localhost:5432/db
API_KEY=your-api-key
ENCRYPTION_KEY=your-encryption-key

# ❌ Avoid: Hardcode secrets in code
const API_KEY = 'sk-1234567890abcdef';
```

### Data Encryption
```typescript
// ✅ Good: Encrypt sensitive data
import crypto from 'crypto';

const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!;
const ALGORITHM = 'aes-256-gcm';

export const encryptData = (data: string): { encrypted: string; iv: string; tag: string } => {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipher(ALGORITHM, ENCRYPTION_KEY);
  cipher.setAAD(Buffer.from('additional-data'));
  
  let encrypted = cipher.update(data, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  return {
    encrypted,
    iv: iv.toString('hex'),
    tag: cipher.getAuthTag().toString('hex'),
  };
};

export const decryptData = (
  encrypted: string,
  iv: string,
  tag: string
): string => {
  const decipher = crypto.createDecipher(ALGORITHM, ENCRYPTION_KEY);
  decipher.setAAD(Buffer.from('additional-data'));
  decipher.setAuthTag(Buffer.from(tag, 'hex'));
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
};
```

### Secure Headers
```typescript
// ✅ Good: Set security headers
import helmet from 'helmet';

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true,
  },
}));

// ✅ Good: CORS configuration
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
}));
```

## API Security

### Rate Limiting
```typescript
// ✅ Good: Implement rate limiting
import rateLimit from 'express-rate-limit';

const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // limit each IP to 5 requests per windowMs
  message: 'Too many authentication attempts, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
});

const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later',
});

app.use('/auth', authLimiter);
app.use('/api', apiLimiter);
```

### Request Validation
```typescript
// ✅ Good: Validate all API requests
const validateApiRequest = (schema: z.ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      schema.parse(req.body);
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          error: 'Invalid request data',
          details: error.errors,
        });
      }
      next(error);
    }
  };
};

// ✅ Good: Usage
const createUserSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  name: z.string().min(2),
});

app.post('/users', validateApiRequest(createUserSchema), createUser);
```

## Error Handling and Logging

### Secure Error Messages
```typescript
// ✅ Good: Don't expose sensitive information in errors
export const handleError = (error: Error, req: Request, res: Response) => {
  // Log the full error for debugging
  console.error('Error:', error);
  
  // Return sanitized error to client
  if (error.name === 'ValidationError') {
    return res.status(400).json({ error: 'Invalid input data' });
  }
  
  if (error.name === 'AuthenticationError') {
    return res.status(401).json({ error: 'Authentication failed' });
  }
  
  // Generic error for unknown issues
  return res.status(500).json({ error: 'Internal server error' });
};

// ❌ Avoid: Exposing sensitive information
// return res.status(500).json({ error: error.message });
```

### Security Logging
```typescript
// ✅ Good: Log security events
export const logSecurityEvent = (
  event: string,
  userId?: string,
  details?: Record<string, any>
) => {
  const logEntry = {
    timestamp: new Date().toISOString(),
    event,
    userId,
    ipAddress: req.ip,
    userAgent: req.headers['user-agent'],
    details,
  };
  
  // Log to secure logging service
  console.log('SECURITY:', JSON.stringify(logEntry));
  
  // Alert on suspicious events
  if (event === 'failed_login' || event === 'unauthorized_access') {
    // Send alert to security team
    sendSecurityAlert(logEntry);
  }
};
```

## Security Monitoring

### Security Headers Monitoring
```typescript
// ✅ Good: Monitor security headers
export const checkSecurityHeaders = (req: Request, res: Response, next: NextFunction) => {
  const requiredHeaders = [
    'X-Content-Type-Options',
    'X-Frame-Options',
    'X-XSS-Protection',
    'Strict-Transport-Security',
  ];
  
  const missingHeaders = requiredHeaders.filter(
    (header) => !res.getHeader(header)
  );
  
  if (missingHeaders.length > 0) {
    console.warn('Missing security headers:', missingHeaders);
  }
  
  next();
};
```

### Security Scanning
```typescript
// ✅ Good: Regular security checks
export const runSecurityChecks = async () => {
  // Check for known vulnerabilities
  const vulnerabilities = await checkDependencies();
  
  // Check for exposed secrets
  const exposedSecrets = await scanForSecrets();
  
  // Check for misconfigurations
  const misconfigurations = await checkConfigurations();
  
  if (vulnerabilities.length > 0 || exposedSecrets.length > 0) {
    sendSecurityAlert({
      vulnerabilities,
      exposedSecrets,
      misconfigurations,
    });
  }
};
```

## Best Practices Summary

### Do's
- Use HTTPS in production
- Implement proper authentication and authorization
- Validate and sanitize all inputs
- Use parameterized queries to prevent SQL injection
- Encrypt sensitive data at rest and in transit
- Set appropriate security headers
- Implement rate limiting
- Log security events
- Regularly update dependencies
- Use environment variables for secrets

### Don'ts
- Don't store passwords in plain text
- Don't expose sensitive information in error messages
- Don't trust user input
- Don't use weak encryption algorithms
- Don't hardcode secrets in code
- Don't skip input validation
- Don't use deprecated security practices
- Don't ignore security warnings
- Don't use default passwords
- Don't expose internal system information

## Security Checklist

### Authentication & Authorization
- [ ] Implement secure JWT tokens
- [ ] Use strong password hashing (bcrypt)
- [ ] Implement proper session management
- [ ] Use role-based access control
- [ ] Protect sensitive routes
- [ ] Implement multi-factor authentication (if needed)

### Input Validation & Sanitization
- [ ] Validate all user inputs
- [ ] Sanitize HTML content
- [ ] Use parameterized queries
- [ ] Implement CSRF protection
- [ ] Validate file uploads

### Data Protection
- [ ] Encrypt sensitive data
- [ ] Use environment variables for secrets
- [ ] Implement secure headers
- [ ] Use HTTPS in production
- [ ] Implement proper CORS

### Monitoring & Logging
- [ ] Log security events
- [ ] Monitor for suspicious activity
- [ ] Implement rate limiting
- [ ] Regular security audits
- [ ] Update dependencies regularly

Follow these security standards to protect your applications and users from common security vulnerabilities and threats.
description:
globs:
alwaysApply: false
---
