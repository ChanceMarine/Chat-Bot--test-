---
description: Universal development standards for all platforms and languages including code quality, performance, security, and best practices
globs: **/*
alwaysApply: true
---
# Development Standards: Universal Best Practices

## Table of Contents
1. [Universal Code Quality Principles](#universal-code-quality-principles)
2. [Platform-Agnostic Architecture](#platform-agnostic-architecture)
3. [Security Standards](#security-standards)
4. [Performance Standards](#performance-standards)
5. [Error Handling](#error-handling)
6. [Testing Standards](#testing-standards)
7. [Documentation Standards](#documentation-standards)
8. [Code Organization](#code-organization)
9. [Quality Metrics](#quality-metrics)
10. [Platform-Specific Adaptations](#platform-specific-adaptations)

---

## Universal Code Quality Principles

### Core Principles (Apply to All Languages/Platforms)

#### Single Responsibility Principle
Every function, class, or module should have one clear, well-defined purpose.

**Examples Across Platforms:**
```javascript
// JavaScript/TypeScript
function calculateTax(amount, rate) {
  return amount * rate;
}

// Python
def calculate_tax(amount: float, rate: float) -> float:
    return amount * rate

// Java
public double calculateTax(double amount, double rate) {
    return amount * rate;
}

// Swift
func calculateTax(amount: Double, rate: Double) -> Double {
    return amount * rate
}

// C#
public double CalculateTax(double amount, double rate) {
    return amount * rate;
}
```

#### DRY (Don't Repeat Yourself)
Eliminate code duplication through abstraction and reusable components.

**Universal Strategies:**
- **Extract Common Logic**: Create shared functions/methods for repeated operations
- **Use Configuration**: Replace hardcoded values with configurable parameters
- **Create Abstractions**: Build reusable components for common patterns
- **Leverage Inheritance/Composition**: Share behavior through appropriate mechanisms

#### KISS (Keep It Simple, Stupid)
Prefer simple, clear solutions over complex ones.

**Universal Guidelines:**
- Choose clarity over cleverness
- Use straightforward algorithms when possible
- Avoid unnecessary abstractions
- Write code that others can easily understand

#### Consistent Naming Conventions
Use clear, descriptive names that follow platform conventions.

**Platform Conventions:**
- **JavaScript/TypeScript**: camelCase for variables/functions, PascalCase for classes
- **Python**: snake_case for variables/functions, PascalCase for classes
- **Java**: camelCase for variables/methods, PascalCase for classes
- **C#**: PascalCase for public members, camelCase for private
- **Swift**: camelCase for variables/functions, PascalCase for types
- **Kotlin**: camelCase for variables/functions, PascalCase for classes

### Code Structure Standards

#### Function/Method Design
- **Single Purpose**: Each function should do one thing well
- **Reasonable Length**: Keep functions under 50 lines when possible
- **Clear Parameters**: Use descriptive parameter names and types
- **Return Values**: Consistent return patterns and error handling

#### Class/Object Design
- **Cohesion**: Related functionality grouped together
- **Loose Coupling**: Minimal dependencies between components
- **Clear Interfaces**: Well-defined public APIs
- **Encapsulation**: Hide internal implementation details

#### Module/Package Organization
- **Logical Grouping**: Related functionality in same module
- **Clear Dependencies**: Explicit and minimal dependencies
- **Public APIs**: Well-defined interfaces between modules
- **Separation of Concerns**: Different responsibilities in different modules

---

## Platform-Agnostic Architecture

### Layered Architecture Pattern
Organize code into distinct layers with clear responsibilities.

#### Presentation Layer
- **Responsibility**: User interface and user interaction
- **Mobile**: Activities/ViewControllers, Fragments/Views
- **Web**: Components, Pages, Templates
- **Desktop**: Windows, Forms, Views
- **API**: Controllers, Endpoints, Routes

#### Business Logic Layer
- **Responsibility**: Core application logic and rules
- **Implementation**: Services, Use Cases, Domain Logic
- **Platform Independence**: Should work regardless of UI or data layer
- **Testing**: Easily testable in isolation

#### Data Access Layer
- **Responsibility**: Data persistence and retrieval
- **Implementation**: Repositories, DAOs, Data Services
- **Abstraction**: Hide specific database/storage implementation
- **Consistency**: Uniform data access patterns

#### Infrastructure Layer
- **Responsibility**: External services and system concerns
- **Implementation**: Logging, Configuration, External APIs
- **Cross-Cutting**: Concerns that span multiple layers
- **Platform Services**: OS-specific functionality

### Dependency Injection Pattern
Manage dependencies through injection rather than direct instantiation.

**Benefits:**
- **Testability**: Easy to mock dependencies for testing
- **Flexibility**: Easy to swap implementations
- **Maintainability**: Loose coupling between components
- **Configuration**: Centralized dependency configuration

### Repository Pattern
Abstract data access behind a consistent interface.

**Universal Implementation:**
```
interface UserRepository {
    findById(id: string): User | null
    findByEmail(email: string): User | null
    save(user: User): void
    delete(id: string): void
}
```

---

## Security Standards

### Input Validation and Sanitization

#### Universal Validation Principles
- **Validate All Inputs**: Never trust user input
- **Whitelist Approach**: Define what is allowed, reject everything else
- **Type Safety**: Use strong typing when available
- **Length Limits**: Enforce reasonable input length limits
- **Format Validation**: Validate format (email, phone, etc.)

#### Platform-Specific Validation
- **Web**: Client-side validation for UX, server-side for security
- **Mobile**: Input validation at UI and business logic layers
- **API**: Comprehensive request validation and sanitization
- **Desktop**: Form validation and data sanitization

### Authentication and Authorization

#### Authentication Standards
- **Strong Passwords**: Enforce complexity requirements
- **Multi-Factor Authentication**: Implement when appropriate
- **Session Management**: Secure session handling
- **Token Security**: Secure token generation and validation

#### Authorization Patterns
- **Role-Based Access Control (RBAC)**: Users have roles with permissions
- **Attribute-Based Access Control (ABAC)**: Fine-grained access control
- **Principle of Least Privilege**: Minimum necessary permissions
- **Defense in Depth**: Multiple layers of authorization

### Data Protection

#### Encryption Standards
- **Data at Rest**: Encrypt sensitive data in storage
- **Data in Transit**: Use TLS/SSL for network communication
- **Key Management**: Secure key storage and rotation
- **Algorithm Choice**: Use industry-standard encryption algorithms

#### Sensitive Data Handling
- **PII Protection**: Special handling for personally identifiable information
- **Data Minimization**: Collect and store only necessary data
- **Secure Deletion**: Properly delete sensitive data when no longer needed
- **Access Logging**: Log access to sensitive data

### Common Security Vulnerabilities

#### Injection Attacks
- **SQL Injection**: Use parameterized queries
- **Command Injection**: Validate and sanitize system commands
- **Script Injection**: Sanitize user input in web contexts
- **LDAP Injection**: Validate LDAP queries

#### Cross-Site Scripting (XSS)
- **Input Sanitization**: Clean user input before display
- **Output Encoding**: Encode output based on context
- **Content Security Policy**: Implement CSP headers
- **Validation**: Validate input format and content

#### Cross-Site Request Forgery (CSRF)
- **CSRF Tokens**: Use anti-CSRF tokens
- **SameSite Cookies**: Configure cookie SameSite attribute
- **Referer Validation**: Validate request origin
- **Double Submit Cookies**: Additional CSRF protection

---

## Performance Standards

### Universal Performance Principles

#### Algorithmic Efficiency
- **Time Complexity**: Choose appropriate algorithms for data size
- **Space Complexity**: Consider memory usage implications
- **Big O Analysis**: Understand performance characteristics
- **Optimization**: Profile before optimizing

#### Resource Management
- **Memory Management**: Proper allocation and deallocation
- **Connection Pooling**: Reuse expensive resources
- **Caching**: Cache frequently accessed data
- **Lazy Loading**: Load resources only when needed

#### Asynchronous Processing
- **Non-Blocking Operations**: Use async patterns for I/O
- **Parallel Processing**: Utilize multiple cores when appropriate
- **Background Tasks**: Move heavy processing off main thread
- **Queue Management**: Handle work queues efficiently

### Platform-Specific Performance

#### Web Applications
- **Bundle Optimization**: Minimize JavaScript/CSS bundle size
- **Image Optimization**: Compress and optimize images
- **CDN Usage**: Use content delivery networks
- **Caching Strategies**: Browser and server-side caching

#### Mobile Applications
- **Battery Optimization**: Minimize battery drain
- **Memory Efficiency**: Manage memory carefully on constrained devices
- **Network Efficiency**: Minimize network requests
- **UI Responsiveness**: Keep UI thread free

#### Desktop Applications
- **Startup Time**: Optimize application startup
- **Resource Usage**: Efficient CPU and memory usage
- **Background Processing**: Handle background tasks appropriately
- **File I/O**: Optimize file operations

#### APIs and Services
- **Response Time**: Target sub-200ms response times
- **Throughput**: Handle expected concurrent requests
- **Database Optimization**: Efficient queries and indexing
- **Scalability**: Design for horizontal scaling

### Performance Monitoring

#### Key Metrics
- **Response Time**: Time to complete operations
- **Throughput**: Operations per second
- **Resource Utilization**: CPU, memory, disk, network usage
- **Error Rates**: Frequency of errors and failures

#### Monitoring Tools
- **Application Performance Monitoring (APM)**: Track application performance
- **Logging**: Comprehensive logging for analysis
- **Metrics Collection**: Collect and analyze performance metrics
- **Alerting**: Alert on performance degradation

---

## Error Handling

### Universal Error Handling Principles

#### Comprehensive Error Handling
- **Anticipate Failures**: Plan for things that can go wrong
- **Graceful Degradation**: Provide fallback functionality
- **User-Friendly Messages**: Clear, actionable error messages
- **Logging**: Detailed logging for debugging

#### Error Classification
- **System Errors**: Infrastructure and platform failures
- **Application Errors**: Business logic and validation errors
- **User Errors**: Invalid input or user actions
- **External Errors**: Third-party service failures

#### Recovery Strategies
- **Retry Logic**: Automatic retry for transient failures
- **Circuit Breaker**: Prevent cascade failures
- **Fallback Mechanisms**: Alternative functionality when primary fails
- **Graceful Shutdown**: Clean shutdown on critical failures

### Platform-Specific Error Handling

#### Web Applications
```javascript
// JavaScript/TypeScript
try {
  const result = await apiCall();
  return result;
} catch (error) {
  if (error.code === 'NETWORK_ERROR') {
    // Handle network issues
    return fallbackData;
  } else if (error.code === 'VALIDATION_ERROR') {
    // Handle validation errors
    showUserError(error.message);
  } else {
    // Handle unexpected errors
    logError(error);
    showGenericError();
  }
}
```

#### Mobile Applications
```swift
// Swift
func fetchUserData(userId: String) async throws -> User {
    do {
        let user = try await apiService.getUser(id: userId)
        return user
    } catch APIError.networkError {
        // Handle network issues
        throw UserError.networkUnavailable
    } catch APIError.notFound {
        // Handle user not found
        throw UserError.userNotFound
    } catch {
        // Handle unexpected errors
        logger.error("Unexpected error: \(error)")
        throw UserError.unknown
    }
}
```

#### Backend Services
```python
# Python
def process_user_request(user_id: str) -> Dict[str, Any]:
    try:
        user = user_repository.get_user(user_id)
        result = business_logic.process(user)
        return {"success": True, "data": result}
    except UserNotFoundError:
        logger.warning(f"User not found: {user_id}")
        return {"success": False, "error": "User not found"}
    except ValidationError as e:
        logger.info(f"Validation error: {e}")
        return {"success": False, "error": str(e)}
    except Exception as e:
        logger.error(f"Unexpected error: {e}", exc_info=True)
        return {"success": False, "error": "Internal server error"}
```

### Error Logging and Monitoring

#### Structured Logging
- **Consistent Format**: Use structured logging format (JSON)
- **Contextual Information**: Include relevant context in logs
- **Log Levels**: Use appropriate log levels (ERROR, WARN, INFO, DEBUG)
- **Correlation IDs**: Track requests across system boundaries

#### Error Tracking
- **Error Aggregation**: Group similar errors together
- **Error Rates**: Monitor error frequency and trends
- **Performance Impact**: Track error impact on performance
- **User Impact**: Understand how errors affect users

---

## Testing Standards

### Universal Testing Principles

#### Test Pyramid
- **Unit Tests (70%)**: Test individual components in isolation
- **Integration Tests (20%)**: Test component interactions
- **End-to-End Tests (10%)**: Test complete user workflows

#### Test Quality Standards
- **Fast Execution**: Tests should run quickly
- **Reliable**: Tests should be deterministic
- **Independent**: Tests should not depend on each other
- **Maintainable**: Tests should be easy to update

#### Test Coverage
- **Code Coverage**: Aim for 80%+ code coverage
- **Branch Coverage**: Test all code paths
- **Functional Coverage**: Test all requirements
- **Edge Case Coverage**: Test boundary conditions

### Platform-Specific Testing

#### Web Applications
- **Unit Tests**: Test individual functions and components
- **Component Tests**: Test UI components in isolation
- **Integration Tests**: Test API endpoints and data flow
- **E2E Tests**: Test complete user workflows in browser

#### Mobile Applications
- **Unit Tests**: Test business logic and utilities
- **UI Tests**: Test user interface components
- **Integration Tests**: Test data layer and services
- **Device Tests**: Test on multiple devices and OS versions

#### APIs and Services
- **Unit Tests**: Test individual functions and methods
- **Integration Tests**: Test database and external service integration
- **Contract Tests**: Test API contracts and schemas
- **Load Tests**: Test performance under load

### Test Automation

#### Continuous Integration
- **Automated Test Execution**: Run tests on every commit
- **Test Result Reporting**: Clear test result visibility
- **Failure Notifications**: Alert on test failures
- **Test Environment Management**: Consistent test environments

#### Test Data Management
- **Test Data Creation**: Automated test data setup
- **Data Isolation**: Tests don't interfere with each other
- **Data Cleanup**: Clean up test data after tests
- **Realistic Data**: Use realistic test data when possible

---

## Documentation Standards

### Code Documentation

#### Inline Comments
- **Purpose**: Explain why, not what
- **Complex Logic**: Document complex algorithms and business rules
- **Assumptions**: Document assumptions and constraints
- **TODOs**: Mark temporary code and future improvements

#### API Documentation
- **Endpoint Documentation**: Clear description of each endpoint
- **Parameter Documentation**: Document all parameters and their types
- **Response Documentation**: Document response format and status codes
- **Example Usage**: Provide example requests and responses

#### Architecture Documentation
- **System Overview**: High-level system architecture
- **Component Relationships**: How components interact
- **Data Flow**: How data moves through the system
- **Decision Records**: Document architectural decisions and rationale

### User Documentation

#### README Files
- **Project Overview**: What the project does and why
- **Installation Instructions**: How to set up and run the project
- **Usage Examples**: How to use the main features
- **Contributing Guidelines**: How others can contribute

#### User Guides
- **Getting Started**: Step-by-step introduction
- **Feature Documentation**: Detailed feature explanations
- **Troubleshooting**: Common issues and solutions
- **FAQ**: Frequently asked questions

---

## Code Organization

### Universal Organization Principles

#### Logical Grouping
- **Related Functionality**: Group related code together
- **Separation of Concerns**: Different responsibilities in different modules
- **Clear Boundaries**: Well-defined interfaces between modules
- **Consistent Structure**: Follow consistent organization patterns

#### Naming Conventions
- **Descriptive Names**: Names should clearly indicate purpose
- **Consistent Patterns**: Follow established naming patterns
- **Avoid Abbreviations**: Use full words when possible
- **Context-Appropriate**: Names should fit their context

#### File and Directory Structure
- **Hierarchical Organization**: Logical hierarchy of directories
- **Flat When Possible**: Avoid deep nesting when not necessary
- **Consistent Naming**: Consistent file and directory naming
- **Clear Purpose**: Each directory should have a clear purpose

### Platform-Specific Organization

#### Web Applications
```
src/
├── components/     # Reusable UI components
├── pages/         # Page components
├── services/      # Business logic and API calls
├── utils/         # Utility functions
├── types/         # Type definitions
├── styles/        # Styling files
└── tests/         # Test files
```

#### Mobile Applications
```
src/
├── screens/       # Screen components
├── components/    # Reusable components
├── services/      # Business logic and API calls
├── models/        # Data models
├── utils/         # Utility functions
├── assets/        # Images, fonts, etc.
└── tests/         # Test files
```

#### Backend Services
```
src/
├── controllers/   # Request handlers
├── services/      # Business logic
├── models/        # Data models
├── repositories/  # Data access layer
├── middleware/    # Request middleware
├── utils/         # Utility functions
├── config/        # Configuration files
└── tests/         # Test files
```

---

## Quality Metrics

### Code Quality Metrics

#### Complexity Metrics
- **Cyclomatic Complexity**: Measure code complexity
- **Cognitive Complexity**: Measure how hard code is to understand
- **Nesting Depth**: Avoid deep nesting
- **Function Length**: Keep functions reasonably sized

#### Maintainability Metrics
- **Code Duplication**: Minimize repeated code
- **Coupling**: Measure dependencies between modules
- **Cohesion**: Measure how related code within modules is
- **Technical Debt**: Track and manage technical debt

#### Quality Gates
- **Code Coverage**: Minimum test coverage thresholds
- **Complexity Limits**: Maximum complexity allowed
- **Duplication Limits**: Maximum code duplication allowed
- **Security Scans**: Automated security vulnerability scanning

### Performance Metrics

#### Response Time Metrics
- **Average Response Time**: Mean response time for operations
- **95th Percentile**: Response time for 95% of requests
- **Maximum Response Time**: Worst-case response time
- **Timeout Rates**: Frequency of operation timeouts

#### Resource Utilization
- **CPU Usage**: Processor utilization patterns
- **Memory Usage**: Memory consumption and leaks
- **Disk I/O**: File system operation efficiency
- **Network Usage**: Network bandwidth utilization

#### Scalability Metrics
- **Concurrent Users**: Maximum concurrent user capacity
- **Throughput**: Operations per second capacity
- **Resource Scaling**: How resources scale with load
- **Breaking Points**: System limits and failure points

---

## Platform-Specific Adaptations

### Web Development
- **Responsive Design**: Support multiple screen sizes
- **Accessibility**: WCAG compliance for inclusive design
- **SEO Optimization**: Search engine optimization
- **Progressive Enhancement**: Graceful degradation for older browsers

### Mobile Development
- **Platform Guidelines**: Follow iOS/Android design guidelines
- **Performance Optimization**: Battery and memory efficiency
- **Offline Support**: Handle network connectivity issues
- **Device Compatibility**: Support multiple device types and sizes

### Desktop Development
- **OS Integration**: Integrate with operating system features
- **Resource Management**: Efficient use of system resources
- **User Experience**: Follow platform-specific UX patterns
- **Installation**: Smooth installation and update processes

### API Development
- **RESTful Design**: Follow REST principles
- **Versioning**: API version management strategy
- **Rate Limiting**: Protect against abuse
- **Documentation**: Comprehensive API documentation

### Database Development
- **Schema Design**: Efficient database schema design
- **Query Optimization**: Optimize database queries
- **Indexing Strategy**: Appropriate database indexing
- **Data Integrity**: Maintain data consistency and integrity

This comprehensive development standards guide provides universal principles that adapt to any platform or technology while maintaining consistency and quality across all development efforts.