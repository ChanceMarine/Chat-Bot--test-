---
description: Comprehensive development standards including code quality, performance, security, and technology guidelines
globs: **/*
alwaysApply: true
---
# Development Standards

## Code Quality Standards

### General Principles
- **Single Responsibility**: Each function/class has one clear purpose
- **DRY (Don't Repeat Yourself)**: Eliminate code duplication
- **KISS (Keep It Simple, Stupid)**: Prefer simple solutions
- **YAGNI (You Aren't Gonna Need It)**: Don't build unnecessary features

### TypeScript Standards
```typescript
// ✅ Good: Explicit typing and interfaces
interface User {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
}

const getUser = async (id: string): Promise<User | null> => {
  return await prisma.user.findUnique({ where: { id } });
};

// ❌ Avoid: Any types and implicit returns
const getUser = async (id: any) => {
  return await prisma.user.findUnique({ where: { id } });
};
```

### React Best Practices
```typescript
// ✅ Good: Functional components with proper typing
interface UserProfileProps {
  user: User;
  onUpdate: (user: User) => void;
}

const UserProfile: React.FC<UserProfileProps> = ({ user, onUpdate }) => {
  const [isEditing, setIsEditing] = useState(false);
  
  useEffect(() => {
    // Proper dependency array
  }, [user.id]);
  
  return <div>{user.name}</div>;
};

// ✅ Good: Custom hooks for reusable logic
const useUserData = (userId: string) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchUser(userId).then(setUser).finally(() => setLoading(false));
  }, [userId]);
  
  return { user, loading };
};
```

### Error Handling
```typescript
// ✅ Good: Comprehensive error handling
export const createUser = async (userData: CreateUserInput): Promise<User> => {
  try {
    const validatedData = userSchema.parse(userData);
    const user = await prisma.user.create({ data: validatedData });
    return user;
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new ValidationError('Invalid user data', error.errors);
    }
    if (error.code === 'P2002') {
      throw new ConflictError('Email already exists');
    }
    throw new InternalError('Failed to create user');
  }
};

// ✅ Good: Error boundaries for React
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}
```

## Performance Standards

### React Optimization
```typescript
// ✅ Good: Memoization for expensive components
const ExpensiveComponent = memo<Props>(({ data, onItemClick }) => {
  const processedData = useMemo(() => {
    return data.map(item => expensiveCalculation(item));
  }, [data]);

  const handleClick = useCallback((id: string) => {
    onItemClick(id);
  }, [onItemClick]);

  return <div>{/* Render processed data */}</div>;
});

// ✅ Good: Code splitting and lazy loading
const HeavyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <HeavyComponent />
    </Suspense>
  );
}
```

### Database Optimization
```typescript
// ✅ Good: Optimized queries with proper selection
export const getUsersWithPosts = async (limit: number = 10) => {
  return prisma.user.findMany({
    take: limit,
    select: {
      id: true,
      name: true,
      email: true,
      posts: {
        select: { id: true, title: true, createdAt: true },
        take: 5,
      },
    },
    orderBy: { createdAt: 'desc' },
  });
};

// ✅ Good: Cursor-based pagination for large datasets
export const getPaginatedPosts = async (cursor?: string, limit: number = 10) => {
  return prisma.post.findMany({
    take: limit,
    skip: cursor ? 1 : 0,
    cursor: cursor ? { id: cursor } : undefined,
    orderBy: { createdAt: 'desc' },
  });
};
```

### Caching Strategies
```typescript
// ✅ Good: Redis caching for expensive operations
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

export const getCachedUser = async (id: string): Promise<User | null> => {
  const cacheKey = `user:${id}`;
  
  // Try cache first
  const cached = await redis.get(cacheKey);
  if (cached) return JSON.parse(cached);
  
  // Fetch from database
  const user = await getUser(id);
  if (user) {
    await redis.setex(cacheKey, 300, JSON.stringify(user)); // 5 min cache
  }
  
  return user;
};

// ✅ Good: React Query for client-side caching
const useUser = (id: string) => {
  return useQuery({
    queryKey: ['user', id],
    queryFn: () => fetchUser(id),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
};
```

## Security Standards

### Authentication & Authorization
```typescript
// ✅ Good: Secure JWT implementation
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';

const JWT_SECRET = process.env.JWT_SECRET!;
const SALT_ROUNDS = 12;

export const hashPassword = async (password: string): Promise<string> => {
  return bcrypt.hash(password, SALT_ROUNDS);
};

export const generateToken = (payload: TokenPayload): string => {
  return jwt.sign(payload, JWT_SECRET, {
    expiresIn: '1h',
    issuer: 'your-app',
    audience: 'your-app-users',
  });
};

// ✅ Good: Role-based access control
export const requireRole = (roles: UserRole[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    next();
  };
};
```

### Input Validation
```typescript
// ✅ Good: Comprehensive validation with Zod
import { z } from 'zod';

const createUserSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Must contain uppercase letter')
    .regex(/[a-z]/, 'Must contain lowercase letter')
    .regex(/[0-9]/, 'Must contain number')
    .regex(/[^A-Za-z0-9]/, 'Must contain special character'),
  name: z.string().min(2).max(100),
});

export const validateCreateUser = (data: unknown) => {
  return createUserSchema.parse(data);
};
```

### Data Protection
```typescript
// ✅ Good: Environment variables for secrets
const config = {
  jwtSecret: process.env.JWT_SECRET!,
  databaseUrl: process.env.DATABASE_URL!,
  apiKey: process.env.API_KEY!,
};

// ✅ Good: Secure headers
import helmet from 'helmet';

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  hsts: { maxAge: 31536000, includeSubDomains: true },
}));

// ✅ Good: Rate limiting
import rateLimit from 'express-rate-limit';

const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts per window
  message: 'Too many authentication attempts',
});
```

## Technology Stack Standards

### Core Technologies
- **React 18.2+**: Functional components with hooks
- **TypeScript 5.1+**: Strict mode enabled
- **Next.js 14+**: App Router architecture
- **Tailwind CSS 3.3+**: Utility-first styling
- **Prisma**: Type-safe database client

### Development Tools
```typescript
// ✅ Good: ESLint configuration
module.exports = {
  extends: [
    'next/core-web-vitals',
    '@typescript-eslint/recommended',
    'prettier',
  ],
  rules: {
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'error',
    'react-hooks/exhaustive-deps': 'error',
  },
};

// ✅ Good: Prettier configuration
module.exports = {
  semi: true,
  trailingComma: 'es5',
  singleQuote: true,
  printWidth: 80,
  tabWidth: 2,
};
```

### Build Configuration
```typescript
// ✅ Good: Vite configuration
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: { '@': path.resolve(__dirname, './src') },
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          ui: ['@radix-ui/react-dialog'],
        },
      },
    },
  },
});
```

## Testing Standards

### Unit Testing
```typescript
// ✅ Good: Component testing with React Testing Library
import { render, screen, fireEvent } from '@testing-library/react';

describe('LoginForm', () => {
  it('submits form with valid data', async () => {
    const mockSubmit = jest.fn();
    render(<LoginForm onSubmit={mockSubmit} />);
    
    fireEvent.change(screen.getByLabelText(/email/i), {
      target: { value: 'test@example.com' },
    });
    fireEvent.change(screen.getByLabelText(/password/i), {
      target: { value: 'password123' },
    });
    fireEvent.click(screen.getByRole('button', { name: /login/i }));
    
    expect(mockSubmit).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password123',
    });
  });
});
```

### Integration Testing
```typescript
// ✅ Good: API testing with Supertest
import request from 'supertest';
import { app } from '../app';

describe('POST /api/users', () => {
  it('creates user with valid data', async () => {
    const userData = {
      email: 'test@example.com',
      password: 'password123',
      name: 'Test User',
    };

    const response = await request(app)
      .post('/api/users')
      .send(userData)
      .expect(201);

    expect(response.body).toMatchObject({
      id: expect.any(String),
      email: userData.email,
      name: userData.name,
    });
  });
});
```

## Quality Metrics

### Code Coverage
- **Minimum 80%** overall coverage
- **90%** for critical business logic
- **95%** for utility functions

### Performance Targets
- **API Response Time**: < 200ms for 95th percentile
- **Page Load Time**: < 3 seconds for initial load
- **Core Web Vitals**: LCP < 2.5s, FID < 100ms, CLS < 0.1

### Security Requirements
- **Authentication**: Multi-factor where appropriate
- **Authorization**: Role-based access control
- **Data Protection**: Encryption at rest and in transit
- **Input Validation**: All inputs validated and sanitized

## Monitoring and Observability

### Error Tracking
```typescript
// ✅ Good: Structured error logging
export const logError = (error: Error, context: Record<string, any>) => {
  console.error('Application Error:', {
    message: error.message,
    stack: error.stack,
    context,
    timestamp: new Date().toISOString(),
  });
};
```

### Performance Monitoring
```typescript
// ✅ Good: Performance metrics
export const trackPerformance = (operation: string, duration: number) => {
  console.log('Performance Metric:', {
    operation,
    duration,
    timestamp: new Date().toISOString(),
  });
  
  if (duration > 1000) {
    console.warn(`Slow operation detected: ${operation} took ${duration}ms`);
  }
};
```

## Best Practices Summary

### Do's
- Use TypeScript with strict mode
- Implement comprehensive error handling
- Write tests for all business logic
- Optimize for performance from the start
- Validate all inputs
- Use environment variables for configuration
- Follow security best practices
- Monitor application performance

### Don'ts
- Use `any` types in TypeScript
- Skip input validation
- Ignore error handling
- Write untested code
- Hardcode secrets in code
- Skip performance considerations
- Ignore security implications
- Deploy without monitoring

These standards ensure consistent, secure, performant, and maintainable code across all development projects.