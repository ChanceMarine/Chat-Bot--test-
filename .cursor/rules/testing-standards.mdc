---
description: Comprehensive testing standards including unit, integration, and end-to-end testing
globs: **/*
alwaysApply: true
---
# Testing Standards

## Overview

This rule defines testing standards and best practices for web applications, including unit testing, integration testing, end-to-end testing, and test organization strategies.

## Testing Philosophy

### Testing Pyramid
```
    /\
   /  \     E2E Tests (Few)
  /____\    Integration Tests (Some)
 /      \   
/________\   Unit Tests (Many)
```

### Testing Principles
- **Test Behavior, Not Implementation**: Focus on what the code does, not how it does it
- **Fast Feedback**: Tests should run quickly to provide immediate feedback
- **Reliable**: Tests should be deterministic and not flaky
- **Maintainable**: Tests should be easy to understand and update
- **Comprehensive**: Cover happy paths, edge cases, and error scenarios

## Unit Testing

### React Component Testing
```typescript
// ✅ Good: Test component behavior
import { render, screen, fireEvent } from '@testing-library/react';
import { LoginForm } from './LoginForm';

describe('LoginForm', () => {
  it('submits form with user input', async () => {
    const mockSubmit = jest.fn();
    render(<LoginForm onSubmit={mockSubmit} />);
    
    // Fill in form
    fireEvent.change(screen.getByLabelText(/email/i), {
      target: { value: 'test@example.com' },
    });
    fireEvent.change(screen.getByLabelText(/password/i), {
      target: { value: 'password123' },
    });
    
    // Submit form
    fireEvent.click(screen.getByRole('button', { name: /login/i }));
    
    // Verify submission
    expect(mockSubmit).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password123',
    });
  });

  it('displays validation errors for invalid input', () => {
    render(<LoginForm onSubmit={jest.fn()} />);
    
    // Submit without filling form
    fireEvent.click(screen.getByRole('button', { name: /login/i }));
    
    // Check for error messages
    expect(screen.getByText(/email is required/i)).toBeInTheDocument();
    expect(screen.getByText(/password is required/i)).toBeInTheDocument();
  });

  it('shows loading state during submission', async () => {
    const mockSubmit = jest.fn(() => new Promise(resolve => setTimeout(resolve, 100)));
    render(<LoginForm onSubmit={mockSubmit} />);
    
    // Fill and submit form
    fireEvent.change(screen.getByLabelText(/email/i), {
      target: { value: 'test@example.com' },
    });
    fireEvent.change(screen.getByLabelText(/password/i), {
      target: { value: 'password123' },
    });
    fireEvent.click(screen.getByRole('button', { name: /login/i }));
    
    // Check loading state
    expect(screen.getByRole('button', { name: /login/i })).toBeDisabled();
    expect(screen.getByText(/loading/i)).toBeInTheDocument();
  });
});
```

### Custom Hook Testing
```typescript
// ✅ Good: Test custom hooks
import { renderHook, act } from '@testing-library/react';
import { useCounter } from './useCounter';

describe('useCounter', () => {
  it('initializes with default value', () => {
    const { result } = renderHook(() => useCounter());
    expect(result.current.count).toBe(0);
  });

  it('initializes with custom value', () => {
    const { result } = renderHook(() => useCounter(10));
    expect(result.current.count).toBe(10);
  });

  it('increments counter', () => {
    const { result } = renderHook(() => useCounter());
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(1);
  });

  it('decrements counter', () => {
    const { result } = renderHook(() => useCounter(5));
    
    act(() => {
      result.current.decrement();
    });
    
    expect(result.current.count).toBe(4);
  });

  it('resets counter', () => {
    const { result } = renderHook(() => useCounter(5));
    
    act(() => {
      result.current.increment();
      result.current.reset();
    });
    
    expect(result.current.count).toBe(0);
  });
});
```

### Utility Function Testing
```typescript
// ✅ Good: Test utility functions
import { formatDate, validateEmail, calculateTotal } from './utils';

describe('formatDate', () => {
  it('formats date correctly', () => {
    const date = new Date('2024-01-15');
    expect(formatDate(date)).toBe('January 15, 2024');
  });

  it('handles invalid date', () => {
    expect(formatDate(null)).toBe('Invalid date');
    expect(formatDate(undefined)).toBe('Invalid date');
  });
});

describe('validateEmail', () => {
  it('validates correct email formats', () => {
    expect(validateEmail('test@example.com')).toBe(true);
    expect(validateEmail('user.name@domain.co.uk')).toBe(true);
  });

  it('rejects invalid email formats', () => {
    expect(validateEmail('invalid-email')).toBe(false);
    expect(validateEmail('test@')).toBe(false);
    expect(validateEmail('@example.com')).toBe(false);
  });
});

describe('calculateTotal', () => {
  it('calculates total with tax', () => {
    const items = [
      { price: 10, quantity: 2 },
      { price: 5, quantity: 1 },
    ];
    const taxRate = 0.1;
    
    expect(calculateTotal(items, taxRate)).toBe(27.5);
  });

  it('handles empty items array', () => {
    expect(calculateTotal([], 0.1)).toBe(0);
  });
});
```

## Integration Testing

### API Route Testing
```typescript
// ✅ Good: Test API routes
import request from 'supertest';
import { app } from '../app';
import { prisma } from '../lib/prisma';

describe('POST /api/users', () => {
  beforeEach(async () => {
    await prisma.user.deleteMany();
  });

  it('creates a new user', async () => {
    const userData = {
      email: 'test@example.com',
      password: 'password123',
      name: 'Test User',
    };

    const response = await request(app)
      .post('/api/users')
      .send(userData)
      .expect(201);

    expect(response.body).toMatchObject({
      id: expect.any(String),
      email: userData.email,
      name: userData.name,
    });
    expect(response.body).not.toHaveProperty('password');

    // Verify user was created in database
    const user = await prisma.user.findUnique({
      where: { email: userData.email },
    });
    expect(user).toBeTruthy();
  });

  it('returns validation error for invalid data', async () => {
    const invalidData = {
      email: 'invalid-email',
      password: '123', // Too short
    };

    const response = await request(app)
      .post('/api/users')
      .send(invalidData)
      .expect(400);

    expect(response.body).toHaveProperty('errors');
    expect(response.body.errors).toHaveLength(2);
  });

  it('prevents duplicate email registration', async () => {
    const userData = {
      email: 'test@example.com',
      password: 'password123',
      name: 'Test User',
    };

    // Create first user
    await request(app).post('/api/users').send(userData);

    // Try to create duplicate
    const response = await request(app)
      .post('/api/users')
      .send(userData)
      .expect(409);

    expect(response.body).toHaveProperty('error', 'Email already exists');
  });
});
```

### Database Integration Testing
```typescript
// ✅ Good: Test database operations
import { prisma } from '../lib/prisma';
import { createUser, getUserById, updateUser } from '../services/userService';

describe('User Service', () => {
  beforeEach(async () => {
    await prisma.user.deleteMany();
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  describe('createUser', () => {
    it('creates user successfully', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'hashedPassword',
        name: 'Test User',
      };

      const user = await createUser(userData);

      expect(user).toMatchObject({
        id: expect.any(String),
        email: userData.email,
        name: userData.name,
      });
      expect(user.password).not.toBe(userData.password); // Should be hashed
    });

    it('throws error for duplicate email', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'hashedPassword',
        name: 'Test User',
      };

      await createUser(userData);

      await expect(createUser(userData)).rejects.toThrow('Email already exists');
    });
  });

  describe('getUserById', () => {
    it('returns user when found', async () => {
      const createdUser = await createUser({
        email: 'test@example.com',
        password: 'hashedPassword',
        name: 'Test User',
      });

      const user = await getUserById(createdUser.id);

      expect(user).toMatchObject({
        id: createdUser.id,
        email: 'test@example.com',
        name: 'Test User',
      });
    });

    it('returns null when user not found', async () => {
      const user = await getUserById('non-existent-id');
      expect(user).toBeNull();
    });
  });
});
```

## End-to-End Testing

### User Journey Testing
```typescript
// ✅ Good: Test complete user workflows
import { test, expect } from '@playwright/test';

test.describe('User Authentication', () => {
  test('user can register and login', async ({ page }) => {
    // Navigate to registration page
    await page.goto('/register');
    
    // Fill registration form
    await page.fill('[data-testid="email-input"]', 'test@example.com');
    await page.fill('[data-testid="password-input"]', 'password123');
    await page.fill('[data-testid="name-input"]', 'Test User');
    
    // Submit registration
    await page.click('[data-testid="register-button"]');
    
    // Verify redirect to login
    await expect(page).toHaveURL('/login');
    await expect(page.locator('[data-testid="success-message"]')).toContainText('Registration successful');
    
    // Login with new account
    await page.fill('[data-testid="email-input"]', 'test@example.com');
    await page.fill('[data-testid="password-input"]', 'password123');
    await page.click('[data-testid="login-button"]');
    
    // Verify successful login
    await expect(page).toHaveURL('/dashboard');
    await expect(page.locator('[data-testid="user-name"]')).toContainText('Test User');
  });

  test('user can create and edit posts', async ({ page }) => {
    // Login first
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'test@example.com');
    await page.fill('[data-testid="password-input"]', 'password123');
    await page.click('[data-testid="login-button"]');
    
    // Navigate to create post page
    await page.click('[data-testid="create-post-link"]');
    
    // Create new post
    await page.fill('[data-testid="title-input"]', 'Test Post');
    await page.fill('[data-testid="content-input"]', 'This is a test post content.');
    await page.click('[data-testid="publish-button"]');
    
    // Verify post was created
    await expect(page).toHaveURL(/\/posts\/\d+/);
    await expect(page.locator('[data-testid="post-title"]')).toContainText('Test Post');
    
    // Edit the post
    await page.click('[data-testid="edit-button"]');
    await page.fill('[data-testid="title-input"]', 'Updated Test Post');
    await page.click('[data-testid="save-button"]');
    
    // Verify post was updated
    await expect(page.locator('[data-testid="post-title"]')).toContainText('Updated Test Post');
  });
});
```

### Critical Path Testing
```typescript
// ✅ Good: Test critical business workflows
test.describe('E-commerce Checkout', () => {
  test('complete purchase flow', async ({ page }) => {
    // Browse products
    await page.goto('/products');
    await page.click('[data-testid="product-card"]');
    
    // Add to cart
    await page.click('[data-testid="add-to-cart"]');
    await expect(page.locator('[data-testid="cart-count"]')).toContainText('1');
    
    // Proceed to checkout
    await page.click('[data-testid="checkout-button"]');
    
    // Fill shipping information
    await page.fill('[data-testid="name-input"]', 'John Doe');
    await page.fill('[data-testid="address-input"]', '123 Main St');
    await page.fill('[data-testid="city-input"]', 'New York');
    await page.fill('[data-testid="zip-input"]', '10001');
    
    // Fill payment information
    await page.fill('[data-testid="card-number"]', '4242424242424242');
    await page.fill('[data-testid="expiry"]', '12/25');
    await page.fill('[data-testid="cvc"]', '123');
    
    // Complete purchase
    await page.click('[data-testid="place-order"]');
    
    // Verify order confirmation
    await expect(page).toHaveURL(/\/order\/\d+/);
    await expect(page.locator('[data-testid="order-status"]')).toContainText('Confirmed');
  });
});
```

## Test Organization

### Test File Structure
```
src/
├── components/
│   ├── Button/
│   │   ├── Button.tsx
│   │   ├── Button.test.tsx
│   │   └── index.ts
│   └── LoginForm/
│       ├── LoginForm.tsx
│       ├── LoginForm.test.tsx
│       └── index.ts
├── utils/
│   ├── formatDate.ts
│   ├── formatDate.test.ts
│   ├── validateEmail.ts
│   └── validateEmail.test.ts
└── services/
    ├── userService.ts
    ├── userService.test.ts
    ├── postService.ts
    └── postService.test.ts
```

### Test Configuration
```typescript
// jest.config.js
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/src/test/setup.ts'],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/test/**/*',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
};

// src/test/setup.ts
import '@testing-library/jest-dom';
import { server } from './mocks/server';

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

## Mocking and Test Data

### API Mocking
```typescript
// ✅ Good: Mock API responses
import { rest } from 'msw';
import { setupServer } from 'msw/node';

const server = setupServer(
  rest.get('/api/users', (req, res, ctx) => {
    return res(
      ctx.json([
        { id: '1', name: 'John Doe', email: 'john@example.com' },
        { id: '2', name: 'Jane Smith', email: 'jane@example.com' },
      ])
    );
  }),

  rest.post('/api/users', (req, res, ctx) => {
    const { name, email } = req.body as any;
    return res(
      ctx.status(201),
      ctx.json({ id: '3', name, email })
    );
  }),

  rest.get('/api/users/:id', (req, res, ctx) => {
    const { id } = req.params;
    return res(
      ctx.json({ id, name: 'John Doe', email: 'john@example.com' })
    );
  })
);

export { server };
```

### Test Data Factories
```typescript
// ✅ Good: Create test data factories
import { faker } from '@faker-js/faker';

export const createUser = (overrides = {}) => ({
  id: faker.string.uuid(),
  email: faker.internet.email(),
  name: faker.person.fullName(),
  createdAt: faker.date.past(),
  ...overrides,
});

export const createPost = (overrides = {}) => ({
  id: faker.string.uuid(),
  title: faker.lorem.sentence(),
  content: faker.lorem.paragraphs(),
  authorId: faker.string.uuid(),
  createdAt: faker.date.past(),
  ...overrides,
});

export const createComment = (overrides = {}) => ({
  id: faker.string.uuid(),
  content: faker.lorem.sentence(),
  authorId: faker.string.uuid(),
  postId: faker.string.uuid(),
  createdAt: faker.date.past(),
  ...overrides,
});
```

## Testing Best Practices

### Test Naming
```typescript
// ✅ Good: Descriptive test names
describe('UserService', () => {
  describe('createUser', () => {
    it('should create a new user with valid data', async () => {
      // Test implementation
    });

    it('should throw error when email already exists', async () => {
      // Test implementation
    });

    it('should hash password before saving', async () => {
      // Test implementation
    });
  });

  describe('getUserById', () => {
    it('should return user when found', async () => {
      // Test implementation
    });

    it('should return null when user not found', async () => {
      // Test implementation
    });
  });
});
```

### Test Isolation
```typescript
// ✅ Good: Isolated tests
describe('UserService', () => {
  beforeEach(async () => {
    // Clean up database before each test
    await prisma.user.deleteMany();
  });

  afterEach(async () => {
    // Clean up after each test
    await prisma.user.deleteMany();
  });

  it('should create user', async () => {
    // Test implementation
  });
});
```

### Async Testing
```typescript
// ✅ Good: Handle async operations properly
describe('UserService', () => {
  it('should create user asynchronously', async () => {
    const userData = { email: 'test@example.com', name: 'Test User' };
    
    const user = await createUser(userData);
    
    expect(user).toMatchObject(userData);
    expect(user.id).toBeDefined();
  });

  it('should handle async errors', async () => {
    const invalidData = { email: 'invalid' };
    
    await expect(createUser(invalidData)).rejects.toThrow('Invalid email');
  });
});
```

## Performance Testing

### Load Testing
```typescript
// ✅ Good: Test application performance
import { test, expect } from '@playwright/test';

test.describe('Performance Tests', () => {
  test('page loads within acceptable time', async ({ page }) => {
    const startTime = Date.now();
    
    await page.goto('/dashboard');
    
    const loadTime = Date.now() - startTime;
    expect(loadTime).toBeLessThan(3000); // 3 seconds
  });

  test('API responds within acceptable time', async ({ request }) => {
    const startTime = Date.now();
    
    const response = await request.get('/api/users');
    
    const responseTime = Date.now() - startTime;
    expect(responseTime).toBeLessThan(1000); // 1 second
    expect(response.status()).toBe(200);
  });
});
```

## Test Coverage

### Coverage Requirements
```typescript
// ✅ Good: Set coverage thresholds
export const coverageThreshold = {
  global: {
    branches: 80,
    functions: 80,
    lines: 80,
    statements: 80,
  },
  './src/components/': {
    branches: 90,
    functions: 90,
    lines: 90,
    statements: 90,
  },
  './src/utils/': {
    branches: 95,
    functions: 95,
    lines: 95,
    statements: 95,
  },
};
```

## Best Practices Summary

### Do's
- Write tests that focus on behavior, not implementation
- Use descriptive test names that explain the scenario
- Keep tests isolated and independent
- Mock external dependencies
- Test both happy paths and error cases
- Use test data factories for consistent test data
- Set up proper test coverage thresholds
- Run tests in CI/CD pipeline
- Use appropriate testing tools for each level

### Don'ts
- Don't test implementation details
- Don't write flaky tests that depend on timing
- Don't skip testing error scenarios
- Don't use hardcoded test data
- Don't ignore test coverage
- Don't test third-party libraries
- Don't write tests that are too slow
- Don't skip integration tests for critical paths

## Testing Checklist

### Unit Testing
- [ ] Test all public functions and methods
- [ ] Test edge cases and error scenarios
- [ ] Mock external dependencies
- [ ] Use descriptive test names
- [ ] Keep tests fast and isolated

### Integration Testing
- [ ] Test API endpoints
- [ ] Test database operations
- [ ] Test component interactions
- [ ] Test authentication flows
- [ ] Test error handling

### E2E Testing
- [ ] Test critical user journeys
- [ ] Test complete workflows
- [ ] Test cross-browser compatibility
- [ ] Test responsive design
- [ ] Test accessibility

### Test Quality
- [ ] Maintain high test coverage
- [ ] Keep tests maintainable
- [ ] Use consistent testing patterns
- [ ] Document complex test scenarios
- [ ] Review and refactor tests regularly

Follow these testing standards to ensure code quality, reliability, and maintainability across your applications.
description:
globs:
alwaysApply: false
---
